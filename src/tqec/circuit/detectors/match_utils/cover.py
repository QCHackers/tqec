import typing as ty

from tqec.circuit.detectors.flow import BoundaryStabilizer
from tqec.circuit.detectors.pauli import PauliString


def _all_pauli_string_combination_results(
    pauli_strings: list[PauliString],
) -> ty.Iterator[tuple[list[bool], PauliString]]:
    """Iterate over all the possible Pauli string products.

    This function iterates over all the `2^{len(pauli_strings)}` products
    that may be generated by either picking or not picking any of the
    provided Pauli strings.

    It is efficient in the sense that it performs the minimum number of
    Pauli products required to do so.

    Args:
        pauli_strings: a list of Pauli strings that will be considered
            in the returned products.

    Yields:
        tuples containing a list of boolean of the exact same size as the
        provided `pauli_strings` list and representing the Pauli strings
        that have been considered in the product returned as the second
        entry of the tuple.
    """
    if len(pauli_strings) == 0:
        yield [], PauliString({})
        return
    yield from (
        ([True] + choices, pauli_strings[0] * res_pauli_string)
        for choices, res_pauli_string in _all_pauli_string_combination_results(
            pauli_strings[1:]
        )
    )
    yield from (
        ([False] + choices, res_pauli_string)
        for choices, res_pauli_string in _all_pauli_string_combination_results(
            pauli_strings[1:]
        )
    )


def find_cover(
    target: BoundaryStabilizer,
    sources: list[BoundaryStabilizer],
    qubit_coordinates: dict[int, tuple[float, ...]],
    maximum_qubit_distance: int = 5,
) -> list[BoundaryStabilizer] | None:
    """Try to cover the provided `target` stabilizer with stabilizers from `sources`.

    This function is currently implemented quite naively: it tries all combinations
    of stabilizers from `sources` and check if one matches with the provided `target`.
    This approach blows up very quickly, as it may test up to `2^{len(sources)}`
    different combinations before being able to tell that no match has been found.

    Args:
        target: the boundary stabilizer to try to match with the provided `sources`.
        sources: the boundary stabilizers that this function will try to combine to
            find a stabilizer involving `target`.
        qubit_coordinates: a mapping from qubit indices to coordinates. Used to
            annotate the matched detectors with the coordinates from the qubits
            involved in the measurement forming the detector.
        maximum_qubit_distance: radius (in number of qubits) to consider when
            searching for covering boundary stabilizers. Any boundary stabilizer
            in `sources` that has coordinates outside of that radius from `target`
            will not be considered, reducing the overall complexity of this
            function. The radius is computed with the Manhattan distance.

    Returns:
        a matching set of boundary stabilizers or None if no matching stabilizers
        could be found.
    """
    assert not target.has_anticommuting_operations

    def manhattan_dist_from_target(source: BoundaryStabilizer) -> float:
        target_coordinates = target.coordinates(qubit_coordinates)
        source_coordinates = source.coordinates(qubit_coordinates)
        return sum(abs(t - s) for t, s in zip(target_coordinates, source_coordinates))

    sources = [
        s for s in sources if manhattan_dist_from_target(s) <= maximum_qubit_distance
    ]

    after_collapse_sources = [s.after_collapse for s in sources]
    for (
        picked_stabilizers,
        resulting_pauli_string,
    ) in _all_pauli_string_combination_results(after_collapse_sources):
        if target.after_collapse == resulting_pauli_string:
            return [
                boundary_stabilizer
                for i, boundary_stabilizer in enumerate(sources)
                if picked_stabilizers[i]
            ]
    return None
