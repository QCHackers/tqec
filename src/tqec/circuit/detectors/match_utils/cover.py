import typing as ty

import pysat
import pysat.solvers
from tqec.circuit.detectors.flow import BoundaryStabilizer
from tqec.circuit.detectors.match_utils.sat import (
    encode_pauli_string_cover_sat_problem_in_solver,
)
from tqec.circuit.detectors.pauli import PauliString


def _all_pauli_string_combination_results(
    pauli_strings: list[PauliString],
) -> ty.Iterator[tuple[list[bool], PauliString]]:
    """Iterate over all the possible Pauli string products.

    This function iterates over all the `2^{len(pauli_strings)}` products
    that may be generated by either picking or not picking any of the
    provided Pauli strings.

    It is efficient in the sense that it performs the minimum number of
    Pauli products required to do so.

    Args:
        pauli_strings: a list of Pauli strings that will be considered
            in the returned products.

    Yields:
        tuples containing a list of boolean of the exact same size as the
        provided `pauli_strings` list and representing the Pauli strings
        that have been considered in the product returned as the second
        entry of the tuple.
    """
    if len(pauli_strings) == 0:
        yield [], PauliString({})
        return
    yield from (
        ([True] + choices, pauli_strings[0] * res_pauli_string)
        for choices, res_pauli_string in _all_pauli_string_combination_results(
            pauli_strings[1:]
        )
    )
    yield from (
        ([False] + choices, res_pauli_string)
        for choices, res_pauli_string in _all_pauli_string_combination_results(
            pauli_strings[1:]
        )
    )


def find_cover(
    target: BoundaryStabilizer,
    sources: list[BoundaryStabilizer],
    qubit_coordinates: dict[int, tuple[float, ...]],
    maximum_qubit_distance: int = 5,
) -> list[BoundaryStabilizer] | None:
    """Try to cover the provided `target` stabilizer with stabilizers from `sources`.

    This function is currently implemented quite naively: it tries all combinations
    of stabilizers from `sources` and check if one matches with the provided `target`.
    This approach blows up very quickly, as it may test up to `2^{len(sources)}`
    different combinations before being able to tell that no match has been found.

    Args:
        target: the boundary stabilizer to try to match with the provided `sources`.
        sources: the boundary stabilizers that this function will try to combine to
            find a stabilizer involving `target`.
        qubit_coordinates: a mapping from qubit indices to coordinates. Used to
            annotate the matched detectors with the coordinates from the qubits
            involved in the measurement forming the detector.
        maximum_qubit_distance: radius (in number of qubits) to consider when
            searching for covering boundary stabilizers. Any boundary stabilizer
            in `sources` that has coordinates outside of that radius from `target`
            will not be considered, reducing the overall complexity of this
            function. The radius is computed with the Manhattan distance.

    Returns:
        a matching set of boundary stabilizers or None if no matching stabilizers
        could be found.
    """
    assert not target.has_anticommuting_operations

    def manhattan_dist_from_target(source: BoundaryStabilizer) -> float:
        target_coordinates = target.coordinates(qubit_coordinates)
        source_coordinates = source.coordinates(qubit_coordinates)
        return sum(abs(t - s) for t, s in zip(target_coordinates, source_coordinates))

    sources = [
        s for s in sources if manhattan_dist_from_target(s) <= maximum_qubit_distance
    ]

    after_collapse_sources = [s.after_collapse for s in sources]
    for (
        picked_stabilizers,
        resulting_pauli_string,
    ) in _all_pauli_string_combination_results(after_collapse_sources):
        if target.after_collapse == resulting_pauli_string:
            return [
                boundary_stabilizer
                for i, boundary_stabilizer in enumerate(sources)
                if picked_stabilizers[i]
            ]
    return None


def find_cover_sat(
    target: BoundaryStabilizer, sources: list[BoundaryStabilizer]
) -> list[BoundaryStabilizer] | None:
    """Try to find a set of boundary stabilizers from `sources` that
    generate target.

    Args:
        target: the stabilizers to cover with stabilizers from `sources`.
        sources: stabilizers that can be used to cover `target`.

    Returns:
        Either a list of a stabilizers that, when combined, cover exactly
        the provided `target`, or None if such a list could not be found.
    """
    if not sources:
        return None
    with pysat.solvers.CryptoMinisat() as solver:
        encode_pauli_string_cover_sat_problem_in_solver(
            solver, target.after_collapse, [source.after_collapse for source in sources]
        )
        if solver.solve():
            # We can ignore type errors in the line below because we know for sure
            # that solver.solve() returned True, so solver.get_model() should return
            # a list of integers representing a solution to the SAT problem.
            # A negative integer `-x` tells that the Pauli string represented by `x`
            # should not be included, whereas a positive integer `x` tells that
            # the Pauli string should be included.
            satisfying_proof: list[int] = solver.get_model()  # type: ignore
            return [sources[i - 1] for i in satisfying_proof if i > 0]
        else:
            return None
